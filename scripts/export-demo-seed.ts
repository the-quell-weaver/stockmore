#!/usr/bin/env ts-node
/**
 * Dev utility: export demo seed fixture from a live org.
 *
 * Usage:
 *   npx ts-node scripts/export-demo-seed.ts <org_id>
 *
 * Reads NEXT_PUBLIC_SUPABASE_URL + SUPABASE_SERVICE_ROLE_KEY from src/.env.local.
 * Writes TypeScript fixture source to stdout — redirect to update seed-fixture.ts:
 *
 *   npx ts-node scripts/export-demo-seed.ts <org_id> \
 *     > src/lib/demo/seed-fixture.ts
 */

import { createClient } from "@supabase/supabase-js";
import * as fs from "fs";
import * as path from "path";

const orgId = process.argv[2];
if (!orgId) {
  console.error("Usage: npx ts-node scripts/export-demo-seed.ts <org_id>");
  process.exit(1);
}

// Load env from src/.env.local
const envPath = path.resolve(__dirname, "../src/.env.local");
if (fs.existsSync(envPath)) {
  const content = fs.readFileSync(envPath, "utf8");
  for (const line of content.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIdx = trimmed.indexOf("=");
    if (eqIdx <= 0) continue;
    const key = trimmed.slice(0, eqIdx).trim();
    const val = trimmed
      .slice(eqIdx + 1)
      .trim()
      .replace(/^["']|["']$/g, "");
    if (!process.env[key]) process.env[key] = val;
  }
}

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !serviceRoleKey) {
  console.error(
    "Missing NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY",
  );
  process.exit(1);
}

const admin = createClient(supabaseUrl, serviceRoleKey, {
  auth: { autoRefreshToken: false, persistSession: false },
});

/** Derive a stable ASCII ref key from a CJK item name. */
function toRef(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, "_")
    .replace(/_+/g, "_")
    .replace(/^_|_$/g, "");
}

async function main() {
  const { data: items, error: itemsErr } = await admin
    .from("items")
    .select("id, name, unit, min_stock, note")
    .eq("org_id", orgId)
    .eq("is_deleted", false)
    .order("name");
  if (itemsErr) {
    console.error("Failed to fetch items:", itemsErr);
    process.exit(1);
  }

  const { data: batches, error: batchesErr } = await admin
    .from("batches")
    .select("item_id, quantity, expiry_date")
    .eq("org_id", orgId)
    .gt("quantity", 0)
    .order("item_id");
  if (batchesErr) {
    console.error("Failed to fetch batches:", batchesErr);
    process.exit(1);
  }

  const itemRefById = new Map(
    (items ?? []).map((i) => [i.id, toRef(i.name)]),
  );

  const seedItems = (items ?? []).map((i) => ({
    ref: toRef(i.name),
    name: i.name,
    unit: i.unit,
    minStock: Number(i.min_stock),
    ...(i.note ? { note: i.note } : {}),
  }));

  const seedBatches = (batches ?? []).map((b) => ({
    itemRef: itemRefById.get(b.item_id) ?? "unknown",
    quantity: Number(b.quantity),
    expiryDate: b.expiry_date ?? null,
  }));

  const lines: string[] = [
    `// Auto-generated by scripts/export-demo-seed.ts — do not edit manually`,
    `// Run: npx ts-node scripts/export-demo-seed.ts <org_id> > src/lib/demo/seed-fixture.ts`,
    ``,
    `export type SeedItem = {`,
    `  /** Internal reference key used by SeedBatch.itemRef */`,
    `  ref: string;`,
    `  name: string;`,
    `  unit: string;`,
    `  minStock: number;`,
    `  note?: string;`,
    `};`,
    ``,
    `export type SeedBatch = {`,
    `  /** Matches SeedItem.ref */`,
    `  itemRef: string;`,
    `  quantity: number;`,
    `  expiryDate: string | null; // YYYY-MM-DD or null`,
    `};`,
    ``,
    `export const SEED_ITEMS: readonly SeedItem[] = ${JSON.stringify(seedItems, null, 2)} as const;`,
    ``,
    `export const SEED_BATCHES: readonly SeedBatch[] = ${JSON.stringify(seedBatches, null, 2)} as const;`,
  ];

  console.log(lines.join("\n"));
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
