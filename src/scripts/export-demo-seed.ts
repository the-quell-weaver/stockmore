#!/usr/bin/env ts-node
/**
 * Dev utility: export demo seed fixture from a live org.
 *
 * Run from within src/ so @supabase/supabase-js resolves:
 *
 *   cd src && npx ts-node scripts/export-demo-seed.ts <org_id>
 *
 * Reads NEXT_PUBLIC_SUPABASE_URL + SUPABASE_SERVICE_ROLE_KEY from .env.local.
 * Writes TypeScript fixture source to stdout — redirect to update seed-fixture.ts:
 *
 *   cd src && npx ts-node scripts/export-demo-seed.ts <org_id> \
 *     > lib/demo/seed-fixture.ts
 */

import { createClient } from "@supabase/supabase-js";
import * as fs from "fs";
import * as path from "path";

const orgId = process.argv[2];
if (!orgId) {
  console.error(
    "Usage: cd src && npx ts-node scripts/export-demo-seed.ts <org_id>",
  );
  process.exit(1);
}

// Load env from src/.env.local (script lives in src/scripts/, so ../ is src/)
const envPath = path.resolve(__dirname, "../.env.local");
if (fs.existsSync(envPath)) {
  const content = fs.readFileSync(envPath, "utf8");
  for (const line of content.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIdx = trimmed.indexOf("=");
    if (eqIdx <= 0) continue;
    const key = trimmed.slice(0, eqIdx).trim();
    const val = trimmed
      .slice(eqIdx + 1)
      .trim()
      .replace(/^["']|["']$/g, "");
    if (!process.env[key]) process.env[key] = val;
  }
}

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !serviceRoleKey) {
  console.error(
    "Missing NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY",
  );
  process.exit(1);
}

const admin = createClient(supabaseUrl, serviceRoleKey, {
  auth: { autoRefreshToken: false, persistSession: false },
});

/**
 * Derive stable, collision-free ASCII ref keys from a list of item names.
 *
 * - ASCII-slugifiable names are slugified (lowercase, non-alphanumeric → "_").
 * - All-CJK (or otherwise empty-slug) names fall back to "item_<index>".
 * - When two names produce the same slug, both are suffixed _1, _2, … so
 *   every emitted ref is unique and round-trips back to the correct item.
 */
function buildRefs(names: string[]): string[] {
  const slugs = names.map((name, idx) => {
    const s = name
      .toLowerCase()
      .replace(/[^a-z0-9]/g, "_")
      .replace(/_+/g, "_")
      .replace(/^_|_$/g, "");
    return s.length > 0 ? s : `item_${idx}`;
  });

  // Count occurrences of each slug to detect collisions.
  const counts = new Map<string, number>();
  for (const slug of slugs) counts.set(slug, (counts.get(slug) ?? 0) + 1);

  // Second pass: suffix colliding slugs with _1, _2, …
  const seen = new Map<string, number>();
  return slugs.map((slug) => {
    if ((counts.get(slug) ?? 0) <= 1) return slug;
    const n = (seen.get(slug) ?? 0) + 1;
    seen.set(slug, n);
    return `${slug}_${n}`;
  });
}

async function main() {
  const { data: items, error: itemsErr } = await admin
    .from("items")
    .select("id, name, unit, min_stock, note")
    .eq("org_id", orgId)
    .eq("is_deleted", false)
    .order("name");
  if (itemsErr) {
    console.error("Failed to fetch items:", itemsErr);
    process.exit(1);
  }

  const { data: batches, error: batchesErr } = await admin
    .from("batches")
    .select("item_id, quantity, expiry_date")
    .eq("org_id", orgId)
    .gt("quantity", 0)
    .order("item_id");
  if (batchesErr) {
    console.error("Failed to fetch batches:", batchesErr);
    process.exit(1);
  }

  const itemList = items ?? [];
  const refs = buildRefs(itemList.map((i) => i.name));

  const itemRefById = new Map(itemList.map((i, idx) => [i.id, refs[idx]]));

  const seedItems = itemList.map((i, idx) => ({
    ref: refs[idx],
    name: i.name,
    unit: i.unit,
    minStock: Number(i.min_stock),
    ...(i.note ? { note: i.note } : {}),
  }));

  const seedBatches = (batches ?? []).map((b) => ({
    itemRef: itemRefById.get(b.item_id) ?? "unknown",
    quantity: Number(b.quantity),
    expiryDate: b.expiry_date ?? null,
  }));

  const lines: string[] = [
    `// Auto-generated by src/scripts/export-demo-seed.ts — do not edit manually`,
    `// Run: cd src && npx ts-node scripts/export-demo-seed.ts <org_id> > lib/demo/seed-fixture.ts`,
    ``,
    `export type SeedItem = {`,
    `  /** Internal reference key used by SeedBatch.itemRef */`,
    `  ref: string;`,
    `  name: string;`,
    `  unit: string;`,
    `  minStock: number;`,
    `  note?: string;`,
    `};`,
    ``,
    `export type SeedBatch = {`,
    `  /** Matches SeedItem.ref */`,
    `  itemRef: string;`,
    `  quantity: number;`,
    `  expiryDate: string | null; // YYYY-MM-DD or null`,
    `};`,
    ``,
    `export const SEED_ITEMS: readonly SeedItem[] = ${JSON.stringify(seedItems, null, 2)} as const;`,
    ``,
    `export const SEED_BATCHES: readonly SeedBatch[] = ${JSON.stringify(seedBatches, null, 2)} as const;`,
  ];

  console.log(lines.join("\n"));
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
